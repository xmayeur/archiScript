/*
 * Ortho relationships
 */
console.clear();

// require some libraries
load(__DIR__ + '/lib/_util.ajs');
load(__DIR__ + "/lib/_fmt_lib.ajs");
// xml = readFile('C:\\Users\\XY56RE\\PycharmProjects\\archiScripts\\examples\\AppDepPat.xml')
//console.log(o)
console.show();
//console.clear();

var incrY = -10;
var incrX = -10;

$(selection).filter('element').forEach(function (e) {
    // console.log(e.name)
    $(e).outRels().forEach(function (o) {
        ortho(o);
    });

});

$(selection).filter("relationship").forEach(function (o) {
    ortho(o);
});

function ortho(o) {
    var view = o.view;
    var rel = o.concept;
    var source = o.source;
    var target = o.target;
    var sb = source.bounds;
    var tb = target.bounds;

    $(source).parents().forEach(function (p) {
        try {
            sb.x += p.bounds.x;
            sb.y += p.bounds.y;
        } catch (e) {
        }
    });

    $(target).parents().forEach(function (p) {
        try {
            tb.x += p.bounds.x;
            tb.y += p.bounds.y;
        } catch (e) {
        }
    });

    sb.cpx = sb.x + (sb.width / 2);
    sb.cpy = sb.y + (sb.height / 2);
    tb.cpx = tb.x + (tb.width / 2);
    tb.cpy = tb.y + (tb.height / 2);

    let dx = tb.cpx - sb.cpx;
    let dy = tb.cpy - sb.cpy;

    // console.log('dx: ', dx, ' dy: ', dy);
    var bps = o.getRelativeBendpoints();

    if (bps.length === 0) {return;}

/*
    if (bps.length === 0) {
        // find if the source and target objects are aligned
        if (   sb.x < tb.x < sb.x + sb.width
            || sb.x < tb.x + tb.width < sb.x + sb.width
            || tb.x < sb.x < tb.x + tb.width
            || tb.x < sb.x + sb.width < tb.x + tb.width
            || sb.y < tb.y < sb.y + sb.height
            || sb.y < tb.y + tb.height < sb.y + sb.height
            || tb.y < sb.y < tb.y + tb.height
            || tb.y < sb.y + sb.height < tb.y + tb.height
        )
        {
            console.log(sb, tb);
            return;
        }     else   {
            // add a bendpoint
            bps = [];
            let b = {
                startX: 20,
                endX: 20 - dx,
                startY: 0,
                endY: dy
            };
            bps.push(b);
            o.addRelativeBendpoint(b, 0);
        }
    }

 */
    /*
    bps.forEach(function(bp){
        console.log('-bp', bp);
    });
    console.log('\n\n');
    */

    // force the first bendpoint position
    bp0 = bps[0];
    bp0.startX += 0;
    bp0.endX = bp0.startX - dx;
    bp0.startY += 0;
    bp0.endY = bp0.startY - dy;
    o.setRelativeBendpoint(bp0, 0);

    var dir = 1;
    if (Math.abs(bp0.startX) < sb.height / 2) {
        dir = 0;
    }
    if (Math.abs(bp0.startY) < sb.width / 2) {
        dir = 1;
    }

    let b = {startX: 0, startY: 0, endX: 0, endY: 0};
    let prev = bp0;
    bps.forEach(function (bp) {
        n = bps.indexOf(bp);
        if (n === 0) {
            b = bp;
        } else if (n === bps.length - 1) {
            b.startX = dx * dir + prev.startX * (1 - dir);
            b.endX = b.startX - dx;
            b.startY = dir * prev.startY + dy * (1 - dir);
            b.endY =  b.startY - dy;


        } else if (n !== 0) {
            b.startX = bp.startX * dir + prev.startX * (1 - dir);
            b.endX = b.startX - dx;
            b.startY = prev.startY * dir + bp.startY * (1 - dir);
            b.endY = b.startY - dy;

        }
        // o.addRelativeBendpoint(b, n);
        o.setRelativeBendpoint(b, n);
        // console.log(n, dir, ' -bp', bp, ' -prev', prev);
        dir = (++dir) % 2;
        prev = bp;
    });

}
