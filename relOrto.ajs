
/*
 * Ortho relationships
 */
console.clear();

// require some libraries
load(__DIR__ + '/lib/_util.ajs');
load(__DIR__ + "/lib/_fmt_lib.ajs");
// xml = readFile('C:\\Users\\XY56RE\\PycharmProjects\\archiScripts\\examples\\AppDepPat.xml')
//console.log(o)
console.show();
//console.clear();

var incrY = -10;
var incrX = -10;

$(selection).filter('element').forEach(function (e) {
    // console.log(e.name)
    $(e).outRels().forEach(function (o) {
        ortho(o);
    });

});

$(selection).filter("relationship").forEach(function (o) {
    ortho(o);
});

// --------------------------------------------------

function setXY(bnd, x, y){
    let xa = Math.abs(x);
    let ya = Math.abs(y);
    let w = bnd.width/2;
    let h = bnd.height/2;

    if (xa > w && ya > h) {
        if (ya/xa < h/w) {
            return {x:x, y:(y/ya)*(h-10), dir:0};
        } else {
            return {x:(x/xa)*(w-10), y:y, dir:1};
        }
    } else if(xa<w && y<h) {
        return {x:Math.max(x, w+10), y:Math.max(y, h+10), dir:1};
    } else {
        return {x:x, y:y, dir:(ya/xa < h/w)};
    }

}

// ---------------------------------------------------
function ortho(o) {
    var view = o.view;
    var rel = o.concept;
    var source = o.source;
    var target = o.target;
    var sb = source.bounds;
    var tb = target.bounds;

    $(source).parents().forEach(function (p) {
        try {
            sb.x += p.bounds.x;
            sb.y += p.bounds.y;
        } catch (e) {
        }
    });

    $(target).parents().forEach(function (p) {
        try {
            tb.x += p.bounds.x;
            tb.y += p.bounds.y;
        } catch (e) {
        }
    });

    sb.cpx = sb.x + (sb.width / 2);
    sb.cpy = sb.y + (sb.height / 2);
    tb.cpx = tb.x + (tb.width / 2);
    tb.cpy = tb.y + (tb.height / 2);

    let dx = tb.cpx - sb.cpx;
    let dy = tb.cpy - sb.cpy;

    // console.log('dx: ', dx, ' dy: ', dy);
    var bps = o.getRelativeBendpoints();

    if (bps.length === 0) {return;}


    // force the first bendpoint position
    let bp0 = bps[0];
    let xy = setXY(sb, bp0.startX, bp0.startY);
    bp0.startX = xy.x;
    bp0.endX = bp0.startX - dx;
    bp0.startY = xy.y;
    bp0.endY = bp0.startY - dy;
    o.setRelativeBendpoint(bp0, 0);
    let dir = xy.dir;

    let b = {startX: 0, startY: 0, endX: 0, endY: 0};
    let prev = bp0;
    bps.forEach(function (bp) {
        n = bps.indexOf(bp);
        if (n === 0) {
            b = bp;
        } else if (n === bps.length - 1) {
            let xy = setXY(tb, bp.endX, bp.endY);
            b.startX = (dx-xy.x)* dir + prev.startX * (1 - dir);
            b.endX = b.startX - dx;
            b.startY = dir * prev.startY + (dy-xy.y)* (1 - dir);
            b.endY =  -b.startY + dy;
        } else if (n !== 0) {
            b.startX = bp.startX * dir + prev.startX * (1 - dir);
            b.endX = b.startX - dx;
            b.startY = prev.startY * dir + bp.startY * (1 - dir);
            b.endY = b.startY - dy;
        }
        // o.addRelativeBendpoint(b, n);
        o.setRelativeBendpoint(b, n);
        console.log(n, dir, ' -bp', bp, ' -prev', prev);
        dir = (++dir) % 2;
        prev = bp;
    });

}
