/*
 *  not working yet
 */
console.show();
console.clear();
var debug = true
var incr = 50;

function log(msg) {
    console.log(msg);
}


function angleBetweenElements(source, target) {
    sb = source.bounds
    tb = target.bounds
    // calculate the angle theta from the deltaY and deltaX values
    // (atan2 returns radians values from [-PI,PI])
    // 0 currently points EAST.
    // NOTE: By preserving Y and X param order to atan2,  we are expecting
    // a CLOCKWISE angle direction.
    theta = Math.atan2(tb.y - sb.y, tb.x - sb.x);

    // convert from radians to degrees
    // this will give you an angle from [0->270],[-180,0]
    angle = theta * 360 / (2 * Math.PI)

    // convert to positive range [0-360)
    // since we want to prevent negative angles, adjust them now.
    // we can assume that atan2 will not return a negative value
    // greater than one partial rotation
    if (angle < 0) {
        angle += 360;
    }

    return angle;
}


/*
$(selection).filter("relationship").forEach(function(o) {
    var view = o.view;
    var rel = o.concept;
    var source = o.source;
    var target = o.target;
    var pp;
    sb = source.bounds;
    tb = target.bounds;

    pp = $(source).parents();
    for (let p in pp) {
        try {
            sb.x += p.bounds.x;
            sb.y += p.bounds.y;
        } catch (e) {
        }
    }

    pp = $(target).parents();
    for (let p in pp) {
        try {
            tb.x += p.bounds.x;
            tb.y += p.bounds.y;
        } catch (e) {
        }
    }

    dx = tb.x - sb.x;
    dy = tb.y - sb.y;
    console.log(sb, ' - ', tb)
    console.log(sb, ' - ', tb)
    a = angleBetweenElements(source, target)
    log(a)
    if (a > 0 && a < 180) {
        dir = -1
    } else {
        dir = 1
    }

    posBP(o, 0, dx / 2 - (tb.length + sb.length) * dir, -dy)
    posBP(o, 1, -dx / 2 + (tb.length + sb.length) * dir, dy + (tb.height + sb.height) * dir)
}
);
*/

doOrtho();

function posBP(rel, bpidx, x, y) {
    var sb = rel.source.bounds;
    var tb = rel.target.bounds;
    var bps = rel.getRelativeBendpoints();
    var bp;
    if (bpidx < bps.length) {
        bp = bps[bpidx]
        console.log(bp)
        bp.startX = x
        bp.endY = y
        bp.endX = 0;
        bp.startY = 0;
        rel.setRelativeBendpoint(bp, bpidx);
    } else {
        bp = {
            "startX": tb.x,
            "endY": sb.y,
            "endX": 0,
            "startY": 0
        }
        rel.addRelativeBendpoint(bp, bps.length);
    }
    bps = rel.getRelativeBendpoints()
    console.log(bps[bpidx])
}


// return the position of a blendpoint with respect to an object as a angle (in degree)
// 0Â° corresponds to the bendpoint being to the right of the object, angle is calculated wrt to clockwize rotation
function bpPos(bp, o, src = true) {
    if (src) {
        if ((Math.abs(bp.startX) < o.bounds.width / 2) && (Math.abs(bp.startY) > o.bounds.height / 2) && bp.startY > 0) {
            return 90
        } else if ((Math.abs(bp.startX) < o.bounds.width / 2) && (Math.abs(bp.startY) > o.bounds.height / 2) && bp.startY < 0) {
            return -90
        } else if ((Math.abs(bp.startX) > o.bounds.width / 2) && (Math.abs(bp.startY) < o.bounds.height / 2) && bp.startX > 0) {
            return 0
        } else if ((Math.abs(bp.startX) > o.bounds.width / 2) && (Math.abs(bp.startY) < o.bounds.height / 2) && bp.startX < 0) {
            return 180
        } else {
            return Math.atan2(bp.startY, bp.startX) * 360 / (2 * Math.PI)
        }
    } else {
        if ((Math.abs(bp.endX) < o.bounds.width / 2) && (Math.abs(bp.endY) > o.bounds.height / 2) && bp.endY > 0) {
            return -90
        } else if ((Math.abs(bp.endX) < o.bounds.width / 2) && (Math.abs(bp.endY) > o.bounds.height / 2) && bp.endY < 0) {
            return 90
        } else if ((Math.abs(bp.endX) > o.bounds.width / 2) && (Math.abs(bp.endY) < o.bounds.height / 2) && bp.endX > 0) {
            return 0
        } else if ((Math.abs(bp.endX) > o.bounds.width / 2) && (Math.abs(bp.endY) < o.bounds.height / 2) && bp.endX < 0) {
            return 180
        } else {
            return -1 * Math.atan2(bp.endY, bp.endX) * 360 / (2 * Math.PI)
        }
    }
}

function alignBp(bp1, bp2, dir) {
    let bp=bp2;
    if (dir) {
        bp.endY = 0
        bp.startY = 0
        //bp.endY = bp1.endY
        bp.startX = bp1.endX
        //bp.endX = bp2.endX
    } else {
        bp.startX = bp1.startX
        // bp.endX = bp1.endX
        //bp.startY = bp2.endY
        //bp.endY = -bp2.startY
    }
    return bp
}

function doOrtho() {
    $(selection).filter("relationship").forEach(function (o) {

        var view = o.view;
        var rel = o.concept;
        var source = o.source;
        var target = o.target;
        var pp;
        sb = source.bounds;
        tb = target.bounds;

        pp = $(source).parents();
        for (let p in pp) {
            try {
                sb.x += p.bounds.x;
                sb.y += p.bounds.y;
            } catch (e) {
            }
        }

        pp = $(target).parents();
        for (let p in pp) {
            try {
                tb.x += p.bounds.x;
                tb.y += p.bounds.y;
            } catch (e) {
            }
        }

        dx = tb.x - sb.x;
        dy = tb.y - sb.y;

        let bps = o.getRelativeBendpoints()
        let blen = bps.length
        console.log("bps: ",bps);
        if (bps.length > 0) {

            log('\n');

            a = bpPos(bps[0], o.source)
            if (blen === 1) {
                bp = bps[0];
                b = bpPos(bp, o.target, false)
                if ((-90 < a <= -45) || (-135 <= a < -90)
                    || (90 < a < 135) || (45 < a < 90)) {
                    bp.startY = 0;
                } else if ((-45 <= a < 0) || (-179 < a < 135) ||
                    (135 < a < 180) || (0 < a < 45)) {
                    bp.startX = 0;
                    bp.startY = 0;
                }
                if ((-90 < b <= -45) || (-135 <= b < -90)
                    || (90 < b < 135) || (45 < b < 90)) {
                    bp.endX = 0;
                } else if ((-45 <= b < 0) || (-179 < b < 135) ||
                    (135 < b < 180) || (0 < b < 45)) {
                    bp.endY = 0;
                }

            }
            o.setRelativeBendpoint(bps[0], 0);
            log('bps_0: '+bps[0])

            dir = a === 0 || a === 180;
            console.log(a, ' - ',dir)
            for (i = 1; i < blen ; i++) {
                bps[i] = alignBp(bps[i - 1], bps[i], dir);
                dir = !dir
                o.setRelativeBendpoint(bps[i], i);
                log(i+' - '+bps[i]);
            }

        }
    });
}
