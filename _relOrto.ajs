/*
 * Ortho relationships
 *
 */
console.clear();
console.show();

// if a view is selected, check all objects
$(selection).filter("archimate-diagram-model").forEach(function (v) {
    function orthoRel(e) {
        $(e).outRels().forEach(function (o) {
            ortho(o);
        });
        $(e).inRels().forEach(function (o) {
            ortho(o);
        });
        $(e).children().filter('element').forEach(function(o){ orthoRel(o);});
    }

    $(v).children().filter('element').forEach(function(e){
        orthoRel(e);
    });
});

// if few objects are selected, managed them
$(selection).filter('element').forEach(function (e) {

    $(e).outRels().forEach(function (o) {
        ortho(o);
    });
    $(e).inRels().forEach(function (o) {
        ortho(o);
    });
});

// if relationships are selected,managed them
$(selection).filter("relationship").forEach(function (o) {
    ortho(o);
});


// --------------------------------------------------

function addFirstBendpoint(s, t, dx, dy) {

    let sxm = s.x + s.width;
    let sym = s.y + s.height;
    let txm = t.x + t.width;
    let tym = t.y + t.height;
    let _b = {};

    if (txm < s.x) {
        _b.startX = -dx / 2;
        _b.endX = dx / 2;
    } else if (t.x > sxm) {
        _b.startX = dx / 2;
        _b.endX = -dx / 2;
    }

    if (tym < s.y) {
        _b.startY = -dy / 2;
        _b.endY = dy / 2;
    } else if (t.y > sym) {
        _b.startY = dy / 2;
        _b.endY = -dy / 2;
    }

    return _b;
}

// --------------------------------------------------

function setXY(bnd, x, y) {
    let xa = Math.abs(x);
    let ya = Math.abs(y);
    let w = bnd.width / 2;
    let h = bnd.height / 2;
    let xm = (x / xa) * Math.max(xa, w + 30);
    let ym = (y / ya) * Math.max(ya, h + 30);
    let hw = bnd.height / bnd.width;

    if ((xa > w && ya > h)) {
        if (ya / xa > hw) {
            return {x: (x / xa) * (w - 10), y: ym, dir: 0};
        } else {
            return {x: xm, y: (y / ya) * (h - 10), dir: 1};

        }
    } else if (xa < w && ya < h) {
        if (ya / xa > hw) {
            return {x: x, y: ym, dir: 0};

        } else {
            return {x: xm, y: y, dir: 1};
        }
    } else if (xa > w && ya < h) {
        return {x: xm, y: y, dir: 1};
    } else if (xa < w && ya > h) {
        return {x: x, y: ym, dir: 0};
    } else {
        return {x: x, y: y, dir: 0}
    }

}

// ---------------------------------------------------
function ortho(o) {
    var view = o.view;
    var rel = o.concept;
    var source = o.source;
    var target = o.target;
    var sb = source.bounds;
    var tb = target.bounds;

    $(source).parents().forEach(function (p) {
        try {
            sb.x += p.bounds.x;
            sb.y += p.bounds.y;
        } catch (e) {
        }
    });

    $(target).parents().forEach(function (p) {
        try {
            tb.x += p.bounds.x;
            tb.y += p.bounds.y;
        } catch (e) {
        }
    });

    sb.cpx = sb.x + (sb.width / 2);
    sb.cpy = sb.y + (sb.height / 2);
    tb.cpx = tb.x + (tb.width / 2);
    tb.cpy = tb.y + (tb.height / 2);

    let dx = tb.cpx - sb.cpx;
    let dy = tb.cpy - sb.cpy;

    var bps = o.getRelativeBendpoints();

    let b = addFirstBendpoint(sb, tb, dx, dy);
    bn = Object.keys(b).length;
    // there is no bendpoint
    if (bps.length === 0) {
        // source & destination objects are not aligned, so create a bendpoint
        if (bn > 2) {
            o.addRelativeBendpoint(b, 0);
            bps = [];
            bps.push(b);
        } else {
            // or leave as is
            return;
        }

    } else if (bps.length === 1) {
        // if objects are aligned and there is only one bendpoint, remove it
        if (bn < 3) {
            o.deleteAllBendpoints();
        }
    }

    // force the first bendpoint position to overcome some flaw after the source have been moved
    let bp0 = bps[0];
    let xy = setXY(sb, bp0.startX, bp0.startY);
    bp0.startX = xy.x;
    bp0.endX = bp0.startX - dx;
    bp0.startY = xy.y;
    bp0.endY = bp0.startY - dy;
    o.setRelativeBendpoint(bp0, 0);
    let dir = xy.dir;

    let n= bps.length;
    if (n > 1) {
        let t_xy = setXY(tb, bps[n-1].endX, bps[n-1].endY);
        // console.log(n, xy, t_xy)
        if (dir === t_xy.dir && n % 2 === 1) {
            o.deleteBendpoint(n-2);
            bps = o.getRelativeBendpoints();
        }
    }
    b = {startX: 0, startY: 0, endX: 0, endY: 0};
    let prev = bp0;
    bps.forEach(function (bp) {
        n = bps.indexOf(bp);
        if (n === 0) {
            b = bp;
        }
        if (n === bps.length - 1) {
            let xy = setXY(tb, bp.endX, bp.endY);
            b.startX = (dx - xy.x) * dir + prev.startX * (1 - dir);
            b.endX = (1 - 2 * dir) * (b.startX - dx);
            b.startY = dir * prev.startY + (dy - xy.y) * (1 - dir);
            b.endY = (-1 + 2 * dir) * (b.startY - dy);
        } else if (n !== 0) {
            b.startX = bp.startX * dir + prev.startX * (1 - dir);
            b.endX = b.startX - dx;
            b.startY = prev.startY * dir + bp.startY * (1 - dir);
            b.endY = b.startY - dy;
        }

        o.setRelativeBendpoint(b, n);

        dir = (++dir) % 2;
        prev = b;
    });

}
