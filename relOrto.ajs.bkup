/*
 *  not working yet
 */
console.show();
console.clear();
let debug = true
let incr = 50;
let bps;
let sb;
let tb;
let prev_b;

/*
function log(msg) {
    console.log(msg);
}


function angleBetweenElements(source, target) {
    sb = source.bounds
    tb = target.bounds
    // calculate the angle theta from the deltaY and deltaX values
    // (atan2 returns radians values from [-PI,PI])
    // 0 currently points EAST.
    // NOTE: By preserving Y and X param order to atan2,  we are expecting
    // a CLOCKWISE angle direction.
    theta = Math.atan2(tb.y - sb.y, tb.x - sb.x);

    // convert from radians to degrees
    // this will give you an angle from [0->270],[-180,0]
    angle = theta * 360 / (2 * Math.PI)

    // convert to positive range [0-360)
    // since we want to prevent negative angles, adjust them now.
    // we can assume that atan2 will not return a negative value
    // greater than one partial rotation
    if (angle < 0) {
        angle += 360;
    }

    return angle;
}

// return the position of a blendpoint with respect to an object as a angle (in degree)
// 0Â° corresponds to the bendpoint being to the right of the object, angle is calculated wrt to clockwize rotation
function bpPos(bp, o, src = true) {
    if (src) {
        if ((Math.abs(bp.startX) < o.bounds.width / 2) && (Math.abs(bp.startY) > o.bounds.height / 2) && bp.startY > 0) {
            return 90
        } else if ((Math.abs(bp.startX) < o.bounds.width / 2) && (Math.abs(bp.startY) > o.bounds.height / 2) && bp.startY < 0) {
            return -90
        } else if ((Math.abs(bp.startX) > o.bounds.width / 2) && (Math.abs(bp.startY) < o.bounds.height / 2) && bp.startX > 0) {
            return 0
        } else if ((Math.abs(bp.startX) > o.bounds.width / 2) && (Math.abs(bp.startY) < o.bounds.height / 2) && bp.startX < 0) {
            return 180
        } else {
            return Math.atan2(bp.startY, bp.startX) * 360 / (2 * Math.PI)
        }
    } else {
        if ((Math.abs(bp.endX) < o.bounds.width / 2) && (Math.abs(bp.endY) > o.bounds.height / 2) && bp.endY > 0) {
            return -90
        } else if ((Math.abs(bp.endX) < o.bounds.width / 2) && (Math.abs(bp.endY) > o.bounds.height / 2) && bp.endY < 0) {
            return 90
        } else if ((Math.abs(bp.endX) > o.bounds.width / 2) && (Math.abs(bp.endY) < o.bounds.height / 2) && bp.endX > 0) {
            return 0
        } else if ((Math.abs(bp.endX) > o.bounds.width / 2) && (Math.abs(bp.endY) < o.bounds.height / 2) && bp.endX < 0) {
            return 180
        } else {
            return -1 * Math.atan2(bp.endY, bp.endX) * 360 / (2 * Math.PI)
        }
    }
}

function alignBp(bp1, bp2, dir) {
    let bp=bp2;
    if (dir) {
        bp.endY = 0
        bp.startY = 0
        //bp.endY = bp1.endY
        bp.startX = bp1.endX
        //bp.endX = bp2.endX
    } else {
        bp.startX = bp1.startX
        // bp.endX = bp1.endX
        //bp.startY = bp2.endY
        //bp.endY = -bp2.startY
    }
    return bp
}
*/

console.log('>');
$(selection).filter("relationship").forEach(function (o) {
    console.log(o)
    let view = o.view;
    let rel = o.concept;
    let source = o.source;
    let target = o.target;
    let pp;
    sb = source.bounds;
    tb = target.bounds;

    pp = $(source).parents();
    for (let p in pp) {
        try {
            sb.x += p.bounds.x;
            sb.y += p.bounds.y;
        } catch (e) {
        }
    }

    pp = $(target).parents();
    for (let p in pp) {
        try {
            tb.x += p.bounds.x;
            tb.y += p.bounds.y;
        } catch (e) {
        }
    }

    dx = tb.x - sb.x // - 2*tb.width + 2*sb.width;
    dy = tb.y - sb.y // - 2*tb.height - 2*sb.height;
    console.log('dx: ', dx, 'dy: ', dy)

    bps = o.getRelativeBendpoints();
    let blen = bps.length;
    console.log("bps: ", bps);
    let dir = undefined;

    bps.forEach(function (b) {

        if (dir === undefined) {
            if (Math.abs(b.startX / sb.width) < 1) {
                dir = true;
            } else if (Math.abs(b.startY / sb.height) < 1) {
                dir = false;
            } else {
                dir = (b.startX / sb.width < b.startY / sb.height);
            }
            if (dir) {
                b.startX = 0;
                b.endX = -dx;
                b.startY = dy/3;
                b.endY = -dy + dy/3;
            } else {
                b.startY = 0;
                b.endY = dy;
                b.endX = dx - b.startX
            }
            console.log('first dir', dir)
        } else {

            if (dir) {
                b.startX = prev_b.startX;
                b.endX = -dx + b.startX;
                b.endY = dy /2;
                b.startY = b.endY - dy
            } else {
                b.endX = 0;
                b.startX = dx
                b.startY = prev_b.startY;
                b.endY = - dy + prev_b.startY
            }

        }
        dir = !dir;
        console.log(b, bps.indexOf(b));
        o.setRelativeBendpoint(b, bps.indexOf(b));
        prev_b = b;
    });

});
