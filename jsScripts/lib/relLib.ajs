// decorator function to apply a relationship-based function to each connection of a selection
function doEachRel(fct) {
    return function decorator() {
        let args = arguments
        // if a view is selected, check all objects
        let sel = args[0]
        $(sel).filter("archimate-diagram-model").forEach(function (v) {
            function _do(e) {
                $(e).outRels().forEach(function (o) {
                    args[0] = o
                    fct.apply(this, args);
                });
                $(e).inRels().forEach(function (o) {
                    args[0] = o

                    fct.apply(this, args);
                });
                $(e).children().filter('element').forEach(function (o) {
                    _do(o);
                });
            }

            $(v).children().filter('element').forEach(function (o) {
                _do(o);
            });
        });
        // if few objects are selected, managed them
        $(sel).filter('element').forEach(function (e) {
            $(e).outRels().forEach(function (o) {
                args[0] = o
                fct.apply(this, args);
            });
            $(e).inRels().forEach(function (o) {
                args[0] = o
                fct.apply(this, args);
            });
        });

        // if relationships are selected,managed them
        $(sel).filter("relationship").forEach(function (o) {
            args[0] = o
            fct.apply(this, args);
        });

    }
}

function addAbsoluteBendpoint(conn, x, y) {

    let s = getObjXY(conn.source)
    let t = getObjXY(conn.target)

    let bp = {
        startX: x - s.x,
        startY: y - s.y,
        endX: x - t.x,
        endY: y - t.y
    }
    conn.addRelativeBendpoint(bp, conn.getRelativeBendpoints().length)

}

function setAbsoluteBendpoint(conn, x, y, idx) {

    // Set the X/Y offset of the embedding objects
    let s = getObjXY(conn.source)
    let t = getObjXY(conn.target)

    let bp = {
        startX: x - s.x,
        startY: y - s.y,
        endX: x - t.x,
        endY: y - t.y
    }
    try {
        conn.setRelativeBendpoint(bp, idx)
    } catch(e){}

}

function getAbsoluteBendpoints(conn) {
    let abps = []
    conn.getRelativeBendpoints().forEach(bp => {
        let x = bp.startX + conn.source.bounds.x + conn.source.bounds.width / 2
        let y = bp.startY + conn.source.bounds.y + conn.source.bounds.height / 2
        // add x/y offset of the embedding objects
        $(conn.source).parents().forEach(p => {
            try {
                x += p.bounds.x
                y += p.bounds.y
            } catch (e) {
            }
        })

        let abp = {
            x: x,
            y: y
        }

        abps.push(abp)
    })
    return abps
}

function getObjXY(obj) {
    let b = obj.bounds
    let x = b.x + b.width / 2
    let y = b.y + b.height / 2
    $(obj).parents().forEach(p => {
        try {
            x += p.bounds.x
            y += p.bounds.y
        } catch (e) {
        }
    })

    return {
        x: x,
        y: y,
        width: b.width,
        height: b.height

    }
}

function isInsideObj(obj, x, y) {
    // TODO add embedding objets X/Y
    let b = getObjXY(obj)
    return (x > b.x && x < b.x + b.width && y > b.y && y < b.y + b.height)
}

function isBetween(i, min, max) {
    return (i >= min && i <= max)
}

function lRel(conn, dir = 0, weight = 0.5) {
    conn.deleteAllBendpoints()
    let sXY = getObjXY(conn.source)
    let tXY = getObjXY(conn.target)

    if (dir === 0 && !isInsideObj(conn.source, tXY.x, sXY.y) && !isInsideObj(conn.target, tXY.x, sXY.y))
        addAbsoluteBendpoint(conn, tXY.x + conn.target.bounds.width * (0.5 - weight), sXY.y)
    else if (dir === 1 && !isInsideObj(conn.source, sXY.x, tXY.y) && !isInsideObj(conn.target, sXY.x, tXY.y))
        addAbsoluteBendpoint(conn, sXY.x, tXY.y + conn.target.bounds.height * (0.5 - weight))
}

function sRel(conn, dir = 0, weightX = 0.5, weightY = 0.5) {
    console.log(dir)
    conn.deleteAllBendpoints()
    let sXY = getObjXY(conn.source)
    let tXY = getObjXY(conn.target)
    let dx = tXY.x - sXY.x
    let dy = tXY.y - sXY.y
    let bp1X, bp1Y, bp2X, bp2Y

    if (dir === 0) {
        bp1X = sXY.x + dx / 2 - conn.source.bounds.width * (0.5 - weightX) / 2
        bp1Y = sXY.y - conn.source.bounds.height * (0.5 - weightY)
        bp2X = bp1X
        bp2Y = tXY.y
    } else {
        bp1X = sXY.x - conn.source.bounds.width * (0.5 - weightX)
        bp1Y = sXY.y + dy / 2 - conn.source.bounds.height * (0.5 - weightY) / 2
        bp2X = tXY.x
        bp2Y = bp1Y
    }

    if (!isInsideObj(conn.source, bp1X, bp1Y)
        && !isInsideObj(conn.target, bp1X, bp1Y)
        && !isInsideObj(conn.source, bp2X, bp2Y)
        && !isInsideObj(conn.target, bp2X, bp2Y)) {

        addAbsoluteBendpoint(conn, bp1X, bp1Y)
        addAbsoluteBendpoint(conn, bp2X, bp2Y)
    }
}

function getObjPos(obj1, obj2) {
    let b1 = ('x' in obj1)?obj1:getObjXY(obj1)
    let b2 = ('x' in obj2)?obj2:getObjXY(obj2)
    let dx = b2.x - b1.x
    let dy = b2.y - b1.y
    let pos

    let angle = Math.atan2(dy, dx) * 180 / Math.PI

    if (!(isBetween(b2.y, b1.y, b1.y + b1.height)
            || isBetween(b2.y + b2.height, b1.y, b1.y + b1.height))
        && !(isBetween(b2.x, b1.x, b1.x + b1.width)
            || isBetween(b2.x + b2.width, b1.x, b1.x + b1.width))
    ) {
        if (angle >= -45 && angle < 45) {
            pos = 'R'

        } else if (angle >= 45 && angle < 135) {
            pos = 'T'

        } else if (angle >= 135 || angle < -135) {
            pos = 'L'

        } else {
            pos = 'B'

        }
    }

    if ((angle > 90 || angle < -135) && (isBetween(b2.y, b1.y, b1.y + b1.height)
        || isBetween(b2.y + b2.height, b1.y, b1.y + b1.height)))
        pos = 'L!'
    else if (angle > 0 && (isBetween(b2.x, b1.x, b1.x + b1.width)
        || isBetween(b2.x + b2.width, b1.x, b1.x + b1.width)))
        pos = 'B!'
    else if (angle < 0 && (isBetween(b2.x, b1.x, b1.x + b1.width)
        || isBetween(b2.x + b2.width, b1.x, b1.x + b1.width)))
        pos = 'T!'
    else if ((isBetween(b2.y, b1.y, b1.y + b1.height)
        || isBetween(b2.y + b2.height, b1.y, b1.y + b1.height)))
        pos = 'R!'


    return pos
}

function getPointPos(obj1, XY) {
    let b = ('x' in obj1)?obj1:getObjXY(obj1)
    let dx = XY.x - b.x
    let dy = XY.y - b.y
    let pos

    let angle = Math.atan2(dy, dx) * 180 / Math.PI

    if (!isBetween(XY.y, b.y, b.y + b.height) && !isBetween(XY.x, b.x, b.x + b.width)) {
        if (angle >= -45 && angle < 45) {
            pos = 'R'

        } else if (angle >= 45 && angle < 135) {
            pos = 'B'

        } else if (angle >= 135 || angle < -135) {
            pos = 'L'

        } else {
            pos = 'T'

        }
    }

    if ((angle > 90 || angle < -135) && isBetween(XY.y, b.y, b.y + b.height))
        pos = 'L!'
    else if (angle > 0 && isBetween(XY.x, b.x, b.x + b.width))
        pos = 'B!'
    else if (angle < 0 && isBetween(XY.x, b.x, b.x + b.width))
        pos = 'T!'
    else if (isBetween(XY.y, b.y, b.y + b.height))
        pos = 'R!'

    return pos
}

function spreadConnections(obj) {
    let top = []
    let bottom = []
    let left = []
    let right = []

    let bo1 = getObjXY(obj)
    $(obj).rels().forEach(r => {
        let bp, bo2, i
        let bps = r.getRelativeBendpoints()
        r.deleteAllBendpoints()
        i = 0
        bps.forEach(_bp => {
            r.addRelativeBendpoint(_bp, i++)
        })

        bps = getAbsoluteBendpoints(r)
        console.log('-> ', bps.length, ...bps, '\n')
        if (bps.length > 0) {
            if (r.target.id === obj.id) {
                bp = bps[bps.length - 1]
                bp.idx = bps.length - 1
                obj2 = r.source
            } else {
                bp = bps[0]
                bp.idx = 0
                obj2 = r.target
            }

            bo2 = getObjXY(obj2)
            let pos = getPointPos(obj, bp)
            console.log (bo2.x, bo2.y, pos, bp)
            if (pos[0] === 'R')
                right.push({order: bo2.y, bp: bp, r: r})
            else if (pos[0] === 'L')
                left.push({order: bo2.y, bp: bp, r: r})
            if (pos[0] === 'T')
                top.push({order: bo2.x, bp: bp, r: r})
            if (pos[0] === 'B')
                bottom.push({order: bo2.y, bp: bp, r: r})
        }

        i = 1
        right.sort(dynamicSort('order')).forEach(r => {
            bp.y = bo1.y + i++ * bo1.height / right.length + 1
            setAbsoluteBendpoint(r.r, bp.x, bp.y, bp.idx)
        })
        i = 1
        left.sort(dynamicSort('order')).forEach(r => {
            bp.y = bo1.y + i++ * bo1.height / left.length + 1
            setAbsoluteBendpoint(r.r, bp.x, bp.y, bp.idx)
        })
        i = 1
        top.sort(dynamicSort('order')).forEach(r => {
            bp.x = bo1.x + i++ * bo1.width / top.length + 1
            setAbsoluteBendpoint(r.r, bp.x, bp.y, bp.idx)
        })
        i = 1
        bottom.sort(dynamicSort('order')).forEach(r => {
            bp.x = bo1.x + bo1.width - i * ( bo1.width / bottom.length + 1)
            i++
            console.log(bp.x, bp.y, bp.idx, r.r.source.name, r.r.target.name)
            setAbsoluteBendpoint(r.r, bp.x, bp.y, bp.idx)
        })


    })



}

function dynamicSort(property) {
    let sortOrder = 1;
    if (property[0] === "-") {
        sortOrder = -1;
        property = property.substr(1);
    }
    return function (a, b) {
        /* next line works with strings and numbers,
         * and you may want to customize it to your needs
         */
        let  result = (a[property] < b[property]) ? -1 : (a[property] > b[property]) ? 1 : 0;
        return result * sortOrder;
    }
}