console.clear()
console.show()

let test = false
let onlyMerge = false

if (test) {
    modelName = __DIR__+'/../mfAppFiles/test/MF_Decomm.archimate'
    mapFile = __DIR__+'/../mfAppFiles/test/Business Objects Analysis.xlsm'
} else {
    modelName = __DIR__+'/../MF_Decomm.archimate'
    mapFile = __DIR__+'/../Business Objects Analysis.xlsm'
}

/**
 * Function to merge a list of 'element' objects into a single one, given by its index in the list
 * @param {object} elems
 * @param {string} idx
 */
function mergeElem(elems, idx = 1) {
    let merge_target = elems.get(idx - 1);
    let to_be_deleted = $("#null");
    let GUID = merge_target.prop('GUID')
    elems.not($(merge_target)).each(function (o) {

        // We don't want to delete while iterating on the collection, so create
        // another collection containing the element (not object) to delete
        to_be_deleted.add(concept(o));
        // do not merge the documentation and properties
        // but consolidate alias property into a single object
        // and merge

        let alias = JSON.parse(o.prop('alias'))
        if (o.prop() != null)
            o.prop().forEach(p => {
                o.removeProp(p);
            });
        o.documentation = ''
        concept(merge_target).merge(concept(o));
        if (merge_target.prop('alias', true) != null)
            merge_target.prop('alias', true).forEach(x => {
                alias = {...alias, ...JSON.parse(x)}
            })
        merge_target.removeProp('alias')
        merge_target.removeProp('GUID')
        merge_target.prop('alias', JSON.stringify(alias))
        merge_target.prop('GUID', GUID)
        embedProperties(merge_target)
    });

    // Deletion loop
    to_be_deleted.each(function (e) {
        e.delete();
    });
}

/**
 * Function to get the concept of an element
 * @param {object} o
 * @return {object}
 */
function concept(o) {
    if (o.concept)
        return o.concept;
    else
        return o;
}

function mapBusinessObjectNames() {
    // library loading for creation of views by scripting
    load(__SCRIPTS_DIR__ + 'lib/lib.ajs');
    // library loading for relationship bend points management
    load(__SCRIPTS_DIR__ + 'lib/relLib.ajs');
    // javascript library for Excel workbook parsing
    load(__SCRIPTS_DIR__ + 'libJs/sheetjs.js')

    log('*** Mapping & merging Business Object Names')

    // Open the MF Decom consolidated model
    mfDecom = $.model.load(modelName)
    mfDecom.setAsCurrent()

    // Open the excel business object files with aliases
    let workbook = XLSX.read(base64encode(readFileSync(mapFile)), {type: 'base64'});
    // Dump file sheet (BO information)  content as JSON object
    let rows = XLSX.utils.sheet_to_json(workbook.Sheets['BO information'], {range: "A1:F300"});

    // Map all non-esperanto business object
    rows.forEach(row => {
        let currentBoName = stripIllegalChar(row['Business_Object'])
        let newBoName = stripIllegalChar(row['Proposed Object'])
        let isEsperanto = (stripIllegalChar(row['isEsperanto']) === 'Yes')
        let baNames = stripIllegalChar(row['Business_Application'])
        baList = baNames.split(',')
        let alias = {}

        if (!isEsperanto && !onlyMerge) {
            let bo = getOrCreateElement('business-object', currentBoName)
            // let newBo = getOrCreateElement('business-object', newBoName)
            if (!!bo && !!newBoName && newBoName !== '' && currentBoName !== newBoName) {
                // get the doc property (without embedded properties)
                let match = bo.documentation.match(/([^]*?)\n*properties=/m);
                doc = (match) ? match[1] : bo.documentation

                // do not replace existing alias definition
                if (!bo.prop('alias')) {
                    baList.forEach(ba =>
                        alias[ba] = {name:currentBoName, documentation: doc}
                    )
                    bo.prop('alias', JSON.stringify(alias, null, 4))
                }

                bo.name = newBoName
                log('Info: ' + currentBoName + ' => ' + newBoName)
            } else {
                log('Error: Invalid Business Object "' + currentBoName + '" or invalid new object name "' + newBoName + '"')
            }
        }
    })

    // merge duplicates - create a list of all business object names
    let boNames = []
    $("business-object").forEach(bo => {
        boNames.push(bo.name)
    })
    // get a list of duplicate items
    const boDups = findDuplicates(boNames)
    boDups.forEach(name => {
        // look into the model for business object with a duplicated name
        let dups = $('.' + name).filter('business-object')
        // if esperanto term exists, we merge into it, else we take the first duplicate as merge target
        let esp = dups.filter(e => {
            return !!e.prop('ESPERANTO')
        }).first()
        let idx = (!!esp) ? dups.indexOf(esp) + 1 : 1
        log('Info: BO merging ' + name)
        mergeElem(dups, idx)
    })

    // save the model
    model.save()
    deb('Done.')
}


mapBusinessObjectNames()