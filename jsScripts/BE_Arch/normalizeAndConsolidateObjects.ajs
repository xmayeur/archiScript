console.clear()
console.show()


// TODO Move some functions to the library lib.ajs

load(__SCRIPTS_DIR__ + 'lib/lib.ajs')
log('normalizeAndConsolidateObjects loading', null, '\n___________________________\n')

/**
 * Function to normalize a name
 *
 * rules:
 *      - use Upper Case for all words
 *      - use singular form for all words
 *
 * @param {string} name
 * @return {string} normlized name
 */
function normalize(name) {
    let exceptions = ['Savings', 'Earnings', 'Goods', 'Premises', 'Securities']
    // remove un-necessary spaces between words in the name
    name = name.replace(/\s+/g, ' ').trim()

    // On each words...
    let words = name.split(' ')
    words = words.map((word) => {
        // Capitalize the word
        word = word[0].toUpperCase() + word.substring(1);

        // skip exceptions
        if (!exceptions.includes(word)) {

            // remove plurals
            // '-ies' -> '-y'
            if (word.substr(-3) === 'ies')
                word = word.substr(0, word.length - 3) + 'y'

            // -oes -> -o
            else if (word.substr(-3) === 'oes')
                word = word.substr(0, word.length - 3) + 'o'

            // -ves -> -f
            else if (word.substr(-3) === 'ves')
                word = word.substr(0, word.length - 3) + 'fe'

            // -hes -> -f
            else if (word.substr(-3) === 'hes')
                word = word.substr(0, word.length - 3) + 'h'

            // sses -> -s
            else if (word.substr(-4) === 'sses')
                word = word.substr(0, word.length - 2)

            // single 's' at the end
            else if (word.substr(-1) === 's' && word.substr(-2) !== 'ss'
                && word.substr(-2) !== 'us' && word.substr(-2) !== 'is')
                word = word.substr(0, word.length - 1)
        }
        return word
    })


    return words.join(" ");
}

/**
 * Function to get the concept of an element
 * @param {object} o
 * @return {object}
 */
function concept(o) {
    if (o.concept)
        return o.concept;
    else
        return o;
}

/**
 * Function to remove the documentation and property of an element
 * @param {object} c
 */
function removeDocAndProps(c) {
    c.documentation = "";
    c.prop().forEach(function (p) {
        c.removeProp(p);
    });
}

/**
 * Function to merge a list of 'element' objects into a single one, given by its index in the list
 * @param {object} elems
 * @param {string} idx
 */
function mergeElem(elems, idx = 1) {
    let merge_target = elems.get(idx - 1);
    let to_be_deleted = $("#null");
    let conns = []

    elems.not($(merge_target)).each(function (o) {

        // We don't want to delete while iterating on the collection, so create
        // another collection containing the element (not object) to delete
        to_be_deleted.add(concept(o));
        // do not merge the documentation and properties
        removeDocAndProps(concept(o));
        // and merge
        concept(merge_target).merge(concept(o));

    });

    // Deletion loop
    to_be_deleted.each(function (e) {
        e.delete();
    });
}

/**
 * Function to find duplicate elements in an array
 * @param {String []} arry
 * @return {String []}
 */
function findDuplicates(arry) {
    const uniqueElements = new Set(arry);
    const filteredElements = arry.filter(item => {
        if (uniqueElements.has(item)) {
            uniqueElements.delete(item);
        } else {
            return item;
        }
    });

    return [...new Set(filteredElements)]
}

// Main

// all Business Objects that are not part of the Esperanto framework
let busObjs = $("business-object")

// normalize the name
busObjs.forEach(bo => {
    bo.name = normalize(bo.name)
})

// get a list of duplicate names
let boNames = []
busObjs.forEach(bo => {
    boNames.push(bo.name)
})

const boDups = findDuplicates(boNames)

// merge duplicates
boDups.forEach(name => {
    let dups = $('.' + name).filter('business-object')
    // if esperanto term exists, we merge into it
    let esp = dups.filter(e => {
        return !!e.prop('ESPERANTO')
    }).first()
    let idx = (!!esp) ? dups.indexOf(esp) + 1 : 1
    log('BO merging ' + name)
    mergeElem(dups, idx)
})

// merge business srv duplicates
// all Business Objects that are not part of the Esperanto framework
let busSrvs = $("business-service")

// normalize the name
busSrvs.forEach(e => {
    e.name = normalize(e.name)
})

// get a list of duplicate names
let eNames = []
busSrvs.forEach(e => {
    eNames.push(e.name)
})

const dups = findDuplicates(eNames)


// merge duplicates
dups.forEach(name => {
    log('BS merging ' + name)
    let dups = $('.' + name)
    mergeElem(dups)
})

// remove 'n/a' objects if any
$('.' + 'n/a').delete()
$('.' + 'N/A').delete()

// Merge redundant relationships having same type, name, source and destination

$('element').each(function(e) {
    let rels = $(e).outRels()
    if (rels.length > 1) {
        // make unique names
        let names = {}
        rels.forEach(r => {
            let name = r.type + "|" + r.name + "|" + r.source.id + "|" + r.target.id
            if (name in names)
                names[name].push(r)
            else {
                names[name] = [r]
            }
        })

        // merge duplicates
        Object.entries(names).forEach(n => {
            const [key, values] = n
            let target_rel = values.pop()
            values.forEach(r => {
                target_rel.merge(r)
                r.delete()
            })
        })

        // expand properties
        expandProperties(e)
    }
})

load(__DIR__+'embedProps.ajs')
load(__DIR__+'removeAllProps.ajs')

model.name = 'MF App Decom'

