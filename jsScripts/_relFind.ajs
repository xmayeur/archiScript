console.clear()
console.show()
load(__SCRIPTS_DIR__ + 'lib/relLib.ajs')
let maze
let x, y
let gap = 2

mazeSolver()

function mazeSolver() {
    let rel = $(selection).filter('relationship').first()
    let obj1 = rel.source
    let obj2 = rel.target
    let b1 = smallBounds(obj1)
    let b2 = smallBounds(obj2)
    let view = obj1.view
    console.log(view)
    // create the "maze"
    createMaze(view)

    let [pos, angle] = getObjPos(obj1, obj2)
    pos = pos.substr(0, 1)
    console.log(pos, angle)
    if (pos === 'T') {
        maze[b1.y - gap][Math.round(b1.x + b1.width / 2 - gap)] = 'S'
        maze [gap + b2.y + b2.height][Math.round(b2.x + b2.width / 2 - gap)] = 'E'
    } else if (pos === 'B') {
        maze[gap + b1.y + b1.height][Math.round(b1.x + b1.width / 2 - gap)] = 'S'
        maze [b2.y - gap][Math.round(b2.x + b2.width/2 -gap)] = 'E'
    } else if (pos === 'L') {
        maze[Math.round(b1.y )][b1.x-gap] = 'S'
        maze [Math.round(b2.y)][gap + b2.x + b2.width] = 'E'
    } else if (pos === 'R') {
        maze[Math.round(b1.y + b1.height / 2-gap)][gap + b1.x + b1.width] = 'S'
        maze [Math.round(b2.y + b2.height / 2 - gap)][b2.x - gap] = 'E'
    }

    // console.log(displayMaze(maze, ' '))
    let start = findStartEnd(maze, 'S');
    let end = findStartEnd(maze, 'E');
    s = [...start]
    e = [...end]
    fillMaze(maze, start);

    let bps = followSolution(maze, end);

    bps.push({
        x: 10 * Math.round(s[1]),
        y: 10 * Math.round(s[0])
    })

    bps = bps.reverse()

    bps.push({
        x: 10 * Math.round(e[1]),
        y: 10 * Math.round(e[0])
    })

    //console.log(displayMaze(maze, '\t'))
    let idx = 0
    console.log(pos, angle)
    rel.deleteAllBendpoints()
    bps.forEach(bp => {
        console.log('bp ', bp)
        addAbsoluteBendpoint(rel, bp.x, bp.y, idx++)
    })
}

function createMaze(view) {
    if (!!view) {
        let minX = 0
        let minY = 0
        let maxX = 0
        let maxY = 0
        let elems = $(view).children()

        elems.forEach(e => {
            try {
                let b = e.bounds
                minX = Math.min(minX, b.x / 10)
                minY = Math.min(minY, b.y / 10)
                maxX = Math.max(maxX, (b.x + b.width) / 10)
                maxY = Math.max(maxY, (b.y + b.height) / 10)
            } catch (e) {
            }
        })
        minX = Math.round(minX)
        minY = Math.round(minY)
        maxX = Math.round(maxX) + 10
        maxY = Math.round(maxY) + 10
        console.log('maze bounds', minX, minY, maxX, maxY)
        maze = []
        for (y = 0; y < maxY - minY; y++) {
            maze.push([])
            for (x = 0; x < maxX - minX; x++) {
                maze[y].push(' ')
            }
        }
        elems.forEach(e => {

            try {
                b = smallBounds(e)
                for (y = b.y - gap; y < b.y + b.height + gap; y++) {
                    for (x = b.x - gap; x < b.x + b.width + gap; x++) {
                        maze[y][x] = 'X'
                    }
                }
            } catch (e) {
            }
        })

    } else {
        console.log('Please select a view!')
    }
}

function followSolution(maze, end) {

    let height = maze.length;
    let width = maze[0].length;
    let prev2 = [0, 0]
    let prev = [1, 1]
    let bps = []
    let cur_step = Math.round(maze[end[0]][end[1]]);
    // console.log(cur_step)

    maze[end[0]][end[1]] = 'o';

    while (cur_step > 1) {
        y = end[0];
        x = end[1];
        // console.log(end);
        // console.log(cur_step);
        let get_out = 0;

        // check each of the neighbours (up down left right)
        for (let ny = -1; ny <= 1; ny++) { // If checking all neighbours this could be max(y-1,0):min(y+1,height)
            for (let nx = -1; nx <= 1; nx++) {
                if (Math.abs(ny) === Math.abs(nx) || y + ny < 0 || y + ny >= height || x + nx < 0 || x + nx >= width)
                    continue;

                if (maze[y + ny][x + nx] === (cur_step - 1).toString()) {
                    end = [y + ny, x + nx];
                    cur_step = Math.round(maze[end[0]][end[1]]);
                    maze[y + ny][x + nx] = 'o';
                    // console.log(y + ny, x + nx)
                    if (
                        (prev2[0] === prev[0] && (y + ny) !== prev[0])
                        ||
                        (prev2[1] === prev[1] && (x + nx) !== prev[1])
                    ) {
                        bps.push({x: 10 * prev[1], y: 10 * prev[0]})
                        console.log('BP: ', 10 * prev[1], 10 * prev[0])
                    }
                    prev2 = prev
                    prev = [y + ny, x + nx]
                    get_out = 1;
                    break;
                }

            }
            if (get_out === 1)
                break;

        }

    }
    return bps
}

function findStartEnd(maze, val) {

    let height = maze.length;
    let width = maze[0].length;

    // find start
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {

            if (maze[y][x] === val) {
                // check the four directions
                for (let ny = -1; ny <= 1; ny++) {
                    for (let nx = -1; nx <= 1; nx++) {
                        if (Math.abs(ny) === Math.abs(nx) || y + ny < 0 || y + ny >= height || x + nx < 0 || x + nx >= width)
                            continue;

                        if (maze[y + ny][x + nx] === ' ')
                            return [y + ny, x + nx];

                    }
                }
            }
        }
    }
}

function fillMaze(maze, start) {

    maze[start[0]][start[1]] = '1';
    let height = maze.length;
    let width = maze[0].length;

    let queue = start;

    while (queue.length !== 0) {

        let y = queue.shift();
        let x = queue.shift();
        let cur_val = Math.round(maze[y][x]);

        // check each of the neighbours
        for (let ny = -1; ny <= 1; ny++) {
            for (let nx = -1; nx <= 1; nx++) {
                if (Math.abs(ny) === Math.abs(nx) || y + ny < 0 || y + ny >= height || x + nx < 0 || x + nx >= width)
                    continue;

                if (maze[y + ny][x + nx] === ' ') {
                    maze[y + ny][x + nx] = (cur_val + 1).toString();
                    queue.push(y + ny);
                    queue.push(x + nx);
                }

            }
        }


    }

}

function displayMaze(maze, space = ' ') {
    let text = [];
    for (let y = 0; y < maze.length; y++)
        text.push(maze[y].join(space) + '\n');
    return text.join('');
}

function smallBounds(e) {
    return {
        x: Math.round(e.bounds.x / 10) + 2,
        y: Math.round(e.bounds.y / 10) + 2,
        width: Math.round(e.bounds.width / 10) + 2,
        height: Math.round(e.bounds.height / 10) + 2
    }
}

function checkRelInView(rel, source, target) {
    let x = null
    $(source).rels().forEach(r => {
        if (r.type === rel.type && (r.target.id === target.id || r.source.id === target.id)) {
            x = r
        }
    })
    return x
}


/**
 * function to retrieve or create a relationship by type, source and target objects
 *
 * @param type      Archimate type of relationship
 * @param name      Relationship Name to set
 * @param source    Source concept object
 * @param target    Target concept object
 * @param create    boolean - true to force creation if the relationship does not exist
 * @param folder    folder object
 * @returns {null|object} relationship object or null in case of error
 */
function getOrCreateRelationship(type = "", name = "", source, target, create = false, folder = null) {
    if (typeof source === 'undefined' || typeof target === 'undefined' || !source || !target)
        return null
    let rel = null;
    let rels = (type === "") ? $(source).outRels() : $(source).outRels(type);
    rels.forEach(function (r) {
        if (r.target.id === target.id) {  //  && r.name === name
            rel = r
        }
    });
    if (!rel && !!create) {
        try {
            rel = (!folder) ? model.createRelationship(type, name, source, target) : model.createRelationship(type, name, source, target, folder);
        } catch (exc) {
            console.log('Error in getOrCreateRelationship ', exc, type, source.name, target.name)
        }
    }
    rel.name = name
    return rel
}
